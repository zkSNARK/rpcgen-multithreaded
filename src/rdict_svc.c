/**
 * Please do not edit this file.
 * It was generated using rpcgen.
 *
 * AUTHORS NOTE : Chris Goebel
 *
 * Obviously this file has been modified.  My assumption is that if
 * the -A or -M flags were working properly in Linux, modifying this
 * file would not be neccessary.  I'm not really sure if this is true
 * and I'm not willing to search through SunOS or rpcgen documentation
 * to find out...
 *
 * Regardless of the above, the file below is actually pretty simple
 * to modify in order to get threads and concurrency working.  You
 * can see that all that was done was to intercept the normal call
 * to the rdictprog_1 function (would normally be called by the
 * rpcgen main).  Instead of allowing that call to go to the
 * appropriate case handlers direcly, we build a thread context
 * and then launch the case handling function under a pthread.
 *
 * This would be an easy place to modify and get c++ thread if
 * you are willing to fix a few compiler errors.  I know this
 * because I did it.
 *
 * Further modifications of this file are probably fine because
 * well... who cares.  Rpcgen is messing it up already so might
 * as well do whatever you want to it as long as you present the
 * same interface.
 */

#include "rdict.h"
#include <memory.h>
#include <netinet/in.h>
#include <rpc/pmap_clnt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>

#ifndef SIG_PF
#define SIG_PF void (*)(int)
#endif

/**
 * These next functions are generated when you compile with -N, and
 * just seem to be unpacking the arguments and then calling the
 * real functions
 */
int _initw_1(void *argp, void *result, struct svc_req *rqstp) {
  (void)argp; 
  return (initw_1_svc(result, rqstp));
}

int _insertw_1(char **argp, void *result, struct svc_req *rqstp) {
  return (insertw_1_svc(*argp, result, rqstp));
}

int _array_example_1(array_example_1_argument *argp, void *result,
                     struct svc_req *rqstp) {
  return (array_example_1_svc(argp->arg1, argp->arg2, result, rqstp));
}

int _matrix_example_1(matrix *argp, void *result, struct svc_req *rqstp) {
  return (matrix_example_1_svc(*argp, result, rqstp));
}

////////////////////////////////////////////////////////
// modified code
pthread_t p_thread;
pthread_attr_t attr;

typedef struct thr_context {
  struct svc_req *rqstp;
  SVCXPRT *transp;
} thr_context;

/* Procedure to be run by thread */
// consider data to be the "thread context" if you are used to pthreads
// However, data is just a wrapper around some memory which contains the
// rqstp and the transp
void *serv_request(void *data) {
  thr_context *context = (thr_context *)data;
  struct svc_req *rqstp = context->rqstp;
  register SVCXPRT *transp = context->transp;
  ////////////////////////////////////////////////////////

  union {
    char *insertw_1_arg;
    array_example_1_argument array_example_1_arg;
    matrix matrix_example_1_arg;
  } argument;
  union {
    int initw_1_res;
    int insertw_1_res;
    int_ptr array_example_1_res;
    matrix matrix_example_1_res;
  } result;
  bool_t retval;
  xdrproc_t _xdr_argument, _xdr_result;
  bool_t (*local)(char *, void *, struct svc_req *);

  switch (rqstp->rq_proc) {
  case NULLPROC:
    (void)svc_sendreply(transp, (xdrproc_t)xdr_void, (char *)NULL);
    return;

  case INITW:
    _xdr_argument = (xdrproc_t)xdr_void;
    _xdr_result = (xdrproc_t)xdr_int;
    local = (bool_t(*)(char *, void *, struct svc_req *))_initw_1;
    break;

  case INSERTW:
    _xdr_argument = (xdrproc_t)xdr_wrapstring;
    _xdr_result = (xdrproc_t)xdr_int;
    local = (bool_t(*)(char *, void *, struct svc_req *))_insertw_1;
    break;

  case ARRAY_EXAMPLE:
    _xdr_argument = (xdrproc_t)xdr_array_example_1_argument;
    _xdr_result = (xdrproc_t)xdr_int_ptr;
    local = (bool_t(*)(char *, void *, struct svc_req *))_array_example_1;
    break;

  case MATRIX_EXAMPLE:
    _xdr_argument = (xdrproc_t)xdr_matrix;
    _xdr_result = (xdrproc_t)xdr_matrix;
    local = (bool_t(*)(char *, void *, struct svc_req *))_matrix_example_1;
    break;

  default:
    svcerr_noproc(transp);
    return;
  }
  memset((char *)&argument, 0, sizeof(argument));
  if (!svc_getargs(transp, (xdrproc_t)_xdr_argument, (caddr_t)&argument)) {
    svcerr_decode(transp);
    return;
  }
  retval = (bool_t)(*local)((char *)&argument, (void *)&result, rqstp);
  if (retval > 0 &&
      !svc_sendreply(transp, (xdrproc_t)_xdr_result, (char *)&result)) {
    svcerr_systemerr(transp);
  }
  if (!svc_freeargs(transp, (xdrproc_t)_xdr_argument, (caddr_t)&argument)) {
    fprintf(stderr, "%s", "unable to free arguments");
    exit(1);
  }
  if (!rdictprog_1_freeresult(transp, _xdr_result, (caddr_t)&result))
    fprintf(stderr, "%s", "unable to free results");

  return;
}

/////////////////////////////////////////////////////////////////
// modified code
/**
 * New code for procedure rdictprog_1 , starting thread
 * in response for each clients request to invoke remote
 * procedure
 */
static void rdictprog_1(struct svc_req *rqstp, register SVCXPRT *transp) {
  thr_context *data_ptr = (thr_context *)malloc(sizeof(thr_context));
  data_ptr->rqstp = rqstp;
  data_ptr->transp = transp;
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  pthread_create(&p_thread, &attr, serv_request, (void *)data_ptr);
}
/////////////////////////////////////////////////////////////////

int main(int argc, char **argv) {
  register SVCXPRT *transp;

  pmap_unset(RDICTPROG, RDICTVERS);

  transp = svcudp_create(RPC_ANYSOCK);
  if (transp == NULL) {
    fprintf(stderr, "%s", "cannot create udp service.");
    exit(1);
  }
  if (!svc_register(transp, RDICTPROG, RDICTVERS, rdictprog_1, IPPROTO_UDP)) {
    fprintf(stderr, "%s", "unable to register (RDICTPROG, RDICTVERS, udp).");
    exit(1);
  }

  transp = svctcp_create(RPC_ANYSOCK, 0, 0);
  if (transp == NULL) {
    fprintf(stderr, "%s", "cannot create tcp service.");
    exit(1);
  }
  if (!svc_register(transp, RDICTPROG, RDICTVERS, rdictprog_1, IPPROTO_TCP)) {
    fprintf(stderr, "%s", "unable to register (RDICTPROG, RDICTVERS, tcp).");
    exit(1);
  }

  svc_run();
  fprintf(stderr, "%s", "svc_run returned");
  exit(1);
  /* NOTREACHED */
}
