/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rdict.h"

#include <assert.h>

int nwords = 0;
char dict[DICTSIZ][MAXWORD + 1];

/**
 * This example comes from the original author.  I'm not sure why he
 * included this other than just to do something simple to show that
 * you can store stuff into variables in this translation unit.
 *
 * Regardless, one interesting thing to note here is that the use of
 * the -N flag causes the result variable to change its type.
 *
 * Compiling with -N allows you to pass multiple arguments, as you
 * can see in an example below, but it also seems to change their type.
 *
 * This example takes in no parameters, but sends the result out the
 * int * result parameter, while returning a bool to indicate the
 * status of the rpc call.  Note that a successful rpc call will result
 * in a return value of TRUE (or 1), which is at odds with most C code
 * out there.  Not sure why rpcgen guys did this.
 */
bool_t initw_1_svc(int *result, struct svc_req *rqstp) {
  (void)rqstp;

  printf("server executing initw_1_svc\n");

  nwords = 0;
  *result = 1;

  printf("completed initw_1_svc\n");
  return TRUE;
}

/**
 * This is another example from the original author.  If you read the
 * notes in the client file, you can see that this passes a c style
 * string by value.  We receive it as 'arg1'.
 *
 * Since the result type is an int, we don't need to do anything
 * special to return it.
 */
bool_t insertw_1_svc(char *arg1, int *result, struct svc_req *rqstp) {
  (void)rqstp;

  printf("server executing insertw_1_svc\n");

  printf("received word %s\n", arg1);
  strcpy(dict[nwords], arg1);
  nwords++;
  *result = nwords;

  printf("completed insertw_1_svc\n");
  return TRUE;
}

/**
 * This example adds the two arrays (arg1 and arg2) together and stores
 * the sum as result.
 *
 * Note that the result which was typed as an 'int_ptr' has not become
 * a struct that was generated for us by rpcgen.
 *
 * In order to send something back to the client here, we need to
 * allocate directly into the result->int_ptr_val and set the
 * result->int_ptr_len.  If we don't set the length, something will
 * blow up.
 */
bool_t array_example_1_svc(int_ptr arg1, int_ptr arg2, int_ptr *result,
                           struct svc_req *rqstp) {
  (void)rqstp;

  printf("server executing array_example_1_svc\n");

  assert(arg1.int_ptr_len == arg2.int_ptr_len);

  result->int_ptr_val = malloc(sizeof(int) * arg1.int_ptr_len);
  result->int_ptr_len = arg1.int_ptr_len;

  for (unsigned int i = 0; i < arg1.int_ptr_len; ++i) {
    result->int_ptr_val[i] = arg1.int_ptr_val[i] + arg2.int_ptr_val[i];
  }

  printf("completed array_example_1_svc\n");
  return TRUE;
}

/**
 * In this example, note that we again need to allocate into the
 * buffer that is inside the 'data' field which is inside the result
 * structure.  We also must set the len field, or again, everything will
 * blow up without mercy
 *
 * Notice that the strcuture that rpcgen created for us is a pretty
 * normal structure with the same variable names on the outside, but
 * in the data field, which is an xdr type, it is just like the one
 * in the above 'array_example_1_svc' when we saw the 'int_ptr'
 * struct used.
 */
bool_t matrix_example_1_svc(matrix arg1, matrix *result,
                            struct svc_req *rqstp) {
  (void)rqstp;

  printf("server executing matrix_example_1_svc\n");

  result->data.int_ptr_val = malloc(sizeof(int) * arg1.data.int_ptr_len);
  result->data.int_ptr_len = arg1.data.int_ptr_len;

  for (unsigned int i = 0; i < result->data.int_ptr_len; ++i) {
    result->data.int_ptr_val[i] = arg1.data.int_ptr_val[i] + 42;
  }

  printf("completed matrix_example_1_svc\n");
  return TRUE;
}

int rdictprog_1_freeresult(SVCXPRT *transp, xdrproc_t xdr_result,
                           caddr_t result) {
  (void)transp;

  xdr_free(xdr_result, result);
  return 1;
}
